# Agent Team Prompt Template

> **Template Version:** 1.0.0

This is the output template Claude fills in when generating an Agent Team Prompt. Replace all `{{PLACEHOLDER}}` values with the user's inputs. Adapt conditional sections based on the user's project and selected roles.

---

## Template Start

```markdown
<!-- Generated by TeamGenesis | Governance v1.0.0 | Template v1.0.0 | Date: {{DATE}} -->

# {{PROJECT_NAME}} — Agent Team Prompt

## 1. Project Context

- **Project:** {{PROJECT_NAME}}
- **Goal:** {{PRIMARY_GOAL}}
- **Tech Stack:** {{TECH_STACK}}
- **Source of Truth:** `{{SOURCE_OF_TRUTH}}`

All architecture, features, and implementation decisions must comply with `{{SOURCE_OF_TRUTH}}`.

---

## 2. Source of Truth Rule

`{{SOURCE_OF_TRUTH}}` is the single source of truth for this project. It overrides all assumptions, prior knowledge, and agent opinions.

**Authority hierarchy:**
1. `{{SOURCE_OF_TRUTH}}` (highest authority)
2. Approved plans (approved by Critic)
3. Team Charter (this document)
4. Agent judgment (lowest — must defer to above)

**Conflict resolution:** If `{{SOURCE_OF_TRUTH}}` is silent or ambiguous on a requirement, **STOP and ask for clarification** — do not infer, assume, or invent.

---

## 3. Team Roster

Create an Agent Team with the following teammates:

{{FOR_EACH_AGENT}}
### {{AGENT_ROLE_NAME}}
**Purpose:** {{AGENT_PURPOSE}}

**Responsibilities:**
- {{RESPONSIBILITY_1}}
- {{RESPONSIBILITY_2}}
- {{RESPONSIBILITY_3}}

**Boundaries (Must NOT):**
- Must NOT {{BOUNDARY_1}}
- Must NOT {{BOUNDARY_2}}
{{END_FOR_EACH}}

---

## 4. Agent Responsibility Blocks

{{FOR_EACH_AGENT}}
### {{AGENT_ROLE_NAME}}

**Scope:** {{OWNED_FILES_AND_MODULES}}

**Deliverables:**
- {{DELIVERABLE_1}} (`{{FILE_PATH_1}}`)
- {{DELIVERABLE_2}} (`{{FILE_PATH_2}}`)

**Definition of Done:**
- [ ] {{DOD_ITEM_1}}
- [ ] {{DOD_ITEM_2}}
- [ ] {{DOD_ITEM_3}}
- [ ] {{DOD_ITEM_4}}
- [ ] No TODO comments without linked issues

**Stop Conditions — HALT and escalate if:**
- `{{SOURCE_OF_TRUTH}}` is ambiguous on a requirement
- A change touches another agent's owned files
- A new dependency is needed that's not in the approved list
- Security invariants would be affected
- {{AGENT_SPECIFIC_STOP_CONDITION}}

**Test Requirements:**
- Unit tests for: {{UNIT_TEST_TARGETS}}
- Integration tests for: {{INTEGRATION_TEST_TARGETS}}

---
{{END_FOR_EACH}}

## 5. Interface Contracts

{{FOR_EACH_CONTRACT}}
### {{AGENT_A}} -> {{AGENT_B}}
- **Input:** {{INPUT_FORMAT_AND_SCHEMA}}
- **Output:** {{OUTPUT_FORMAT_AND_SCHEMA}}
- **Example:**
```{{FORMAT}}
{{CONCRETE_EXAMPLE}}
```
{{END_FOR_EACH}}

---

## 6. Approval Protocol

**No code may be written before plan approval.**

Before implementing any feature, the responsible agent must submit a plan containing:
1. **Steps** — Ordered sequence of what will be built
2. **Files touched/created** — Exact paths
3. **Data formats** — Schemas with concrete examples (not just descriptions)
4. **Edge cases** — What could go wrong + how it's handled
5. **Test approach** — What tests, what they cover, what they mock
6. **Rollback strategy** — How to undo if something breaks

**Approval flow:**
1. Implementer (or assigned agent) writes the plan
2. Critic reviews the plan (NOT the code) for: completeness, architectural consistency, security compliance, testability, edge case coverage
3. Critic approves (pass) or rejects (fail + specific feedback)
4. If rejected: revise and resubmit — no partial approvals
5. Only after approval: implementation begins

---

## 7. Stop Conditions (Global)

**ALL agents must STOP immediately if:**
- `{{SOURCE_OF_TRUTH}}` is missing or ambiguous on a requirement
- A change touches security constraints ({{SECURITY_AREAS}})
- Any agent proposes a new dependency not in `{{SOURCE_OF_TRUTH}}`
- A proposed change would break an existing interface contract
- The implementation would require modifying another agent's owned files

**Action when stopped:** Follow the Escalation Protocol below.

---

## 7.1. Escalation Protocol

When an agent halts (due to a stop condition or ambiguity), follow this process:

**Escalation format:**
```markdown
## Escalation: [Short title]
- **Decision needed:** [What must be decided]
- **Options:** [2-3 concrete options]
- **Recommendation:** [What this agent recommends and why]
- **Blocked work:** [What cannot proceed until this is resolved]
```

**Rules:**
1. **All escalations go to the user.** Format using the template above so the user can decide quickly.
2. **If the user is unavailable:** Log the escalation in `CLAUDE.md` as a "Pending Decision," mark status as `blocked` in `TEAM_AGENTS.json`, and stop work on the blocked task. Unrelated tasks may continue.
3. **Agent-to-agent disagreements:** Each agent writes their position as an RFC. The Critic arbitrates implementation disputes; the Architect arbitrates architecture disputes. If the arbiter cannot resolve or is party to the disagreement, escalate to the user.
4. **Boundary overrides are forbidden.** No agent may override another agent's "Must NOT" boundary. Boundary changes require explicit user approval.

---

## 8. Change Control (RFC Process)

Any feature, dependency, or architectural change NOT in `{{SOURCE_OF_TRUTH}}` requires an RFC before implementation.

**RFC format:**
```markdown
## RFC: [Title]
- **Why needed:** [What problem this solves]
- **Impacted files/commands:** [What changes]
- **Risk/complexity:** [Low / Medium / High + explanation]
- **Approval required from:** [Critic / Architect]
```

RFCs must be approved by the Critic before any implementation begins.

---

## 9. Operational Constraints

- **Runtime:** {{TECH_STACK}}
- **Module system:** {{MODULE_SYSTEM}}
- **Sandboxed write paths:** {{ALLOWED_WRITE_PATHS}}
- **Dependency policy:** No external dependencies without RFC approval
- **Simplicity rule:** Prefer simplest implementation. No new frameworks without approval. If it can be done in 20 lines without a library, do it in 20 lines.

---

## 10. Security Invariants (Unchangeable Rules)

These rules **must never be broken** regardless of convenience or efficiency:

{{FOR_EACH_INVARIANT}}
- {{SECURITY_INVARIANT}}
{{END_FOR_EACH}}

If an implementation would violate any security invariant, the agent must **STOP and escalate** — not work around it.

---

## 11. Documentation Sync Rule

All agents must update `CLAUDE.md` when making architectural decisions, technology choices, or trade-offs.

**Required format:**
```markdown
## Decision: [Short title]
- **Context:** [Why this decision was needed]
- **Alternatives considered:** [What other options existed]
- **Chosen approach:** [What was selected and why]
- **Consequences:** [What this enables, what it constrains]
- **Owner:** [Agent role] | **Date:** [YYYY-MM-DD]
```

**Rule:** Every decision that affects architecture, technology choices, or trade-offs must be logged. An unlogged decision is an incomplete decision.

---

## 12. Budget and Simplicity Constraints

- Prefer the **simplest implementation** that meets requirements
- No new frameworks or libraries without RFC approval
- Reuse existing project infrastructure before building new
- Phase 2/3 features must not block Phase 1 delivery
- No premature abstractions — three similar lines > one premature helper

---

## 13. Agent Persistence (Save & Reuse)

At the end of each work session, save the entire team to `TEAM_AGENTS.json`. This file captures every agent's identity, goals, and completed work so the team can be reloaded later.

**Save location:** `TEAM_AGENTS.json` (project root)

**JSON schema:**
```json
{
  "team": {
    "project_name": "{{PROJECT_NAME}}",
    "source_of_truth": "{{SOURCE_OF_TRUTH}}",
    "governance_version": "1.0.0",
    "created": "YYYY-MM-DD",
    "last_session": "YYYY-MM-DD",
    "session_count": 1
  },
  "agents": [
    {{FOR_EACH_AGENT}}
    {
      "role": "{{AGENT_ROLE_NAME}}",
      "purpose": "{{AGENT_PURPOSE}}",
      "scope": ["{{OWNED_FILES_AND_MODULES}}"],
      "boundaries": [
        "Must NOT {{BOUNDARY_1}}",
        "Must NOT {{BOUNDARY_2}}"
      ],
      "goals": [
        "{{GOAL_1}}",
        "{{GOAL_2}}"
      ],
      "interface_contracts": {
        "outputs_to": ["{{AGENT_B}}"],
        "inputs_from": ["{{AGENT_A}}"]
      },
      "status": "completed | blocked | escalated",
      "work_completed": [
        {
          "task": "Description of task",
          "status": "completed | in_progress | blocked",
          "deliverables": ["file/path/1", "file/path/2"]
        }
      ],
      "files_touched": {
        "created": [],
        "modified": [],
        "deleted": []
      },
      "blockers": []
    }
    {{END_FOR_EACH}}
  ]
}
```

**When to save:** At the end of every session, the lead agent updates `TEAM_AGENTS.json` with each agent's current status, completed work, and any blockers.

**When to load:** At the start of a session, if `TEAM_AGENTS.json` exists, agents read it to understand:
- Their own role, scope, and boundaries (identity)
- What they previously completed (history)
- What other agents did (team context)
- What's blocked and needs resolution (continuity)

**Reuse scenarios:**
- **Continue** — Same agents, same goals, pick up where they left off
- **Update** — Same agents, new/modified goals, but with full history of prior work
- **New feature** — Same team composition for a different feature, fresh goals, prior work archived

**Relationship to Section 11:**
- Section 11 (CLAUDE.md) captures *why* decisions were made (strategic, human-readable)
- Section 13 (TEAM_AGENTS.json) captures *who* did *what* and *who they are* (structural, machine-readable)
- Together they give a new session full context without reverse-engineering git history

---

## High-Leverage One-Liners

- Treat `{{SOURCE_OF_TRUTH}}` as law; never invent requirements.
- If unclear, ask a question OR write an RFC — **do not guess**.
- Output schemas first, then logic.
- Prefer deterministic code; LLM/AI used only where specified.
- Every change must preserve security invariants.
- Test strategy is a deliverable, not an afterthought.

---

## Prompting Architecture

**Layer 1 — Team Charter (this document):** Defines global rules, boundaries, approval gates, and constraints. Immutable during a session.

**Layer 2 — Per-Agent Micro-Prompts:** Specific task instructions generated per session. Each micro-prompt references this Team Charter and adds the specific task, context, and acceptance criteria for that agent's current work.

Micro-prompts must not contradict the Team Charter.

---

End of {{PROJECT_NAME}} Agent Team Prompt.
```

## Template End

---

## Placeholder Reference

Every `{{PLACEHOLDER}}` in the template above must be replaced with a concrete value. The `{{FOR_EACH_*}}` / `{{END_FOR_EACH}}` blocks are iteration markers — generate one copy of the enclosed content for each item (agent, contract, or invariant).

| Placeholder | Type | Description | Example |
|---|---|---|---|
| `{{DATE}}` | string (YYYY-MM-DD) | Date of generation | `2026-02-17` |
| `{{PROJECT_NAME}}` | string | User-provided project name | `TaskFlow` |
| `{{PRIMARY_GOAL}}` | string | One-sentence project goal | `Build a REST API for task management with user auth` |
| `{{TECH_STACK}}` | string | Languages, frameworks, runtime | `Node 20, TypeScript, Express, PostgreSQL` |
| `{{SOURCE_OF_TRUTH}}` | string (file path) | Canonical spec file path | `PROJECT_BRIEF.md` |
| `{{AGENT_ROLE_NAME}}` | string | Role title for this agent | `Architect`, `CLI/DX Specialist` |
| `{{AGENT_PURPOSE}}` | string | One-line purpose statement | `Define data models, API surface, and system boundaries` |
| `{{RESPONSIBILITY_N}}` | string | One specific responsibility | `Design Prisma schemas for users and tasks` |
| `{{BOUNDARY_N}}` | string | One "Must NOT" rule (without the "Must NOT" prefix) | `write implementation code` |
| `{{OWNED_FILES_AND_MODULES}}` | string | Specific files/directories this agent owns | `prisma/schema.prisma`, `src/types/` |
| `{{DELIVERABLE_N}}` | string | Description of a deliverable | `Prisma schema` |
| `{{FILE_PATH_N}}` | string (file path) | Specific file path for a deliverable | `prisma/schema.prisma` |
| `{{DOD_ITEM_N}}` | string | Measurable yes/no checkable item | `All planned files created/updated` |
| `{{AGENT_SPECIFIC_STOP_CONDITION}}` | string | Domain-specific halt condition for this agent | `A proposed feature requires a third-party auth provider not in the spec` |
| `{{UNIT_TEST_TARGETS}}` | string | What to unit test | `schema validation helpers, type guard functions` |
| `{{INTEGRATION_TEST_TARGETS}}` | string | What to integration test | `Prisma migration runs cleanly, seed data loads` |
| `{{AGENT_A}}` / `{{AGENT_B}}` | string | Role names in a contract pair | `Architect`, `Implementer` |
| `{{INPUT_FORMAT_AND_SCHEMA}}` | string | Exact input format with schema details | `Prisma schema (prisma/schema.prisma) + TypeScript types (src/types/*.ts)` |
| `{{OUTPUT_FORMAT_AND_SCHEMA}}` | string | Exact output format | `Implementation follows schema exactly; changes go through RFC` |
| `{{FORMAT}}` | string | Code block language tag | `typescript`, `json`, `yaml`, `bash` |
| `{{CONCRETE_EXAMPLE}}` | string (code) | Real code/data example | A real JSON object, TypeScript interface, or CLI command |
| `{{SECURITY_AREAS}}` | string (comma-separated) | Security domains relevant to this project | `JWT auth, rate limiting, input validation` |
| `{{MODULE_SYSTEM}}` | string | Module/import system used | `ESM only`, `CommonJS`, `Python packages`, `Go modules` |
| `{{ALLOWED_WRITE_PATHS}}` | string (comma-separated paths) | Directories agents may write to | `src/`, `prisma/`, `docs/`, `tests/` |
| `{{SECURITY_INVARIANT}}` | string | One non-negotiable security rule | `All user input validated at system boundaries` |
| `{{GOAL_N}}` | string | One goal for this agent this session | `Design Prisma schemas for users, tasks, and permissions` |

**Iteration blocks:**
- `{{FOR_EACH_AGENT}}` ... `{{END_FOR_EACH}}` — Generate one block per agent on the team
- `{{FOR_EACH_CONTRACT}}` ... `{{END_FOR_EACH}}` — Generate one block per interface contract between agent pairs
- `{{FOR_EACH_INVARIANT}}` ... `{{END_FOR_EACH}}` — Generate one block per security invariant

---

## Generation Notes for Claude

When filling in this template:

1. **Replace all `{{PLACEHOLDER}}` values** with the user's actual inputs. No `{{...}}` syntax should remain in the final output.
2. **Generate `{{FOR_EACH}}` blocks** dynamically based on the selected roles and project context.
3. **Be specific** — file paths, schema examples, and test targets should reference real project structure, not generic placeholders.
4. **Security invariants:** If the user didn't provide any, use these defaults:
   - No secrets (API keys, passwords, tokens) in source code or logs
   - All user input validated at system boundaries
   - Parameterized queries for all database operations
   - HTML output escapes user-derived content
5. **Interface contract examples** must include concrete data, not just format descriptions. Show a real JSON object, a real CLI command, a real file path.
6. **Definition of Done items** must be verifiable (yes/no checkable). Not "code is clean" — instead "no TODO comments without linked issues."
7. **Write the output to the file** specified by the user (default: `./AGENT_TEAM_PROMPT.md`). Do not print the entire prompt to chat — write to file, then show a summary.
